y<-c(18.2, 18.9, 12.9, 14.4, 27.2, 24, 22.4, 22.5, 15.9, 14.5, 15.1, 14.2, 41, 43.9, 36.3, 39.9)
A <- rep(c(-1,1), each = 4, times = 2)
B <- rep(c(-1,1), each = 8)
dat1 <- data.frame(y,A,B)
dat1
aov(y~A*B)
summary(aov(y~A*B))
?table1
library(tidyverse)
?table1
install.packages("rayshader")
install.packages("rayshader")
install.packages("rayshader")
# To install the latest version from Github:
# install.packages("devtools")
devtools::install_github("tylermorganwall/rayshader")
install.packages("C:/Users/mdtak/Downloads/Compressed/rayshader_0.24.10.tar.gz", repos = NULL, type = "source")
library(rayshader)
render_water(
heightmap,
waterdepth = 0,
watercolor = "lightblue",
zscale = 1,
wateralpha = 0.5,
waterlinecolor = NULL,
waterlinealpha = 1,
linewidth = 2,
remove_water = TRUE
)
if(interactive()) {
## Not run:
montereybay %>%
sphere_shade() %>%
plot_3d(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#We want to add a layer of water after the initial render.
## Not run:
render_water(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#Call it again to change the water depth
## Not run:
render_water(montereybay,zscale=50,waterdepth=-1000)
render_snapshot()
## End(Not run)
#Add waterlines
## Not run:
render_camera(theta=-45)
render_water(montereybay,zscale=50,waterlinecolor="white")
render_snapshot(clear = TRUE)
rgl::rgl.close()
## End(Not run)
}
if(interactive()) {
## Not run:
montereybay %>%
sphere_shade() %>%
plot_3d(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#We want to add a layer of water after the initial render.
## Not run:
render_water(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#Call it again to change the water depth
## Not run:
render_water(montereybay,zscale=50,waterdepth=-1000)
render_snapshot()
## End(Not run)
#Add waterlines
## Not run:
render_camera(theta=-45)
render_water(montereybay,zscale=50,waterlinecolor="white")
render_snapshot(clear = TRUE)
rgl::rgl.close()
## End(Not run)
}
if(interactive()) {
## Not run:
montereybay %>%
sphere_shade() %>%
plot_3d(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#We want to add a layer of water after the initial render.
## Not run:
render_water(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#Call it again to change the water depth
## Not run:
render_water(montereybay,zscale=50,waterdepth=-1000)
render_snapshot()
## End(Not run)
#Add waterlines
## Not run:
render_camera(theta=-45)
render_water(montereybay,zscale=50,waterlinecolor="white")
render_snapshot(clear = TRUE)
rgl::rgl.close()
## End(Not run)
}
if(interactive()) {
## Not run:
montereybay %>%
sphere_shade() %>%
plot_3d(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#We want to add a layer of water after the initial render.
## Not run:
render_water(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#Call it again to change the water depth
## Not run:
render_water(montereybay,zscale=50,waterdepth=-1000)
render_snapshot()
## End(Not run)
#Add waterlines
## Not run:
render_camera(theta=-45)
render_water(montereybay,zscale=50,waterlinecolor="white")
render_snapshot(clear = TRUE)
rgl::rgl.close()
## End(Not run)
}
if(interactive()) {
## Not run:
montereybay %>%
sphere_shade() %>%
plot_3d(montereybay,zscale=50)
render_snapshot()
## End(Not run)
#We want to add a layer of water after the initial render.
## Not run:
render_water(montereybay,zscale=100)
render_snapshot()
## End(Not run)
#Call it again to change the water depth
## Not run:
render_water(montereybay,zscale=50,waterdepth=-1000)
render_snapshot()
## End(Not run)
#Add waterlines
## Not run:
render_camera(theta=-45)
render_water(montereybay,zscale=50,waterlinecolor="white")
render_snapshot(clear = TRUE)
rgl::rgl.close()
## End(Not run)
}
design <- data.frame(A = rep(c(0, 1), 16),
B = rep(c(0, 1), 8),
C = rep(c(0, 1), 4),
D = rep(c(0, 1), 2),
E = rep(c(0, 1), 1))
View(design)
design$interaction <- design$A*design$B*design$C*design$D*design$E
View(design)
design <- data.frame(A = rep(c(0, 1), 16),
B = rep(c(0, 1), each=2, 8),
C = rep(c(0, 1), each=4, 4),
D = rep(c(0, 1), each=8, 2)
)
design$interaction <- design$A*design$B*design$C*design$D
View(design)
design <- data.frame(A = rep(c(-1, 1), 16),
B = rep(c(-1, 1), each=2, 8),
C = rep(c(-1, 1), each=4, 4),
D = rep(c(-1, 1), each=8, 2)
)
design$interaction <- design$A*design$B*design$C*design$D
# Add a column for the response variable
design$response <- rnorm(32)
# Add a column for the response variable
design$response <- rnorm(50,64,32)
# Add a column for the response variable
design$response <- rnorm(32,50,64)
# Fit a linear model to the data
fit <- lm(response ~ A*B*C*D + interaction, data = design)
# Print the summary of the model
summary(fit)
# Create an interaction plot for the highest interaction
interaction.plot(design$interaction, design$response)
# Print the summary of the model
summary(fit)
# Create an interaction plot for the highest interaction
interaction.plot(design$interaction, design$response)
library(lattice)
design <- data.frame(A = rep(c(-1, 1), 16),
B = rep(c(-1, 1), each=2, 8),
C = rep(c(-1, 1), each=4, 4),
D = rep(c(-1, 1), each=8, 2)
)
design$interaction <- design$A*design$B*design$C*design$D
# Add a column for the response variable
design$response <- rnorm(32,50,64)
# Fit a linear model to the data
fit <- lm(response ~ A*B*C*D + interaction, data = design)
# Print the summary of the model
summary(fit)
# Create an interaction plot for the highest interaction
interaction.plot(design$interaction, design$response)
library(lattice)
# Create a data frame for the design
design <- data.frame(A = rep(c(0, 1), 16),
B = rep(c(0, 1), 8),
C = rep(c(0, 1), 4),
D = rep(c(0, 1), 2),
E = rep(c(0, 1), 1))
# Add a column for the highest interaction
design$interaction <- design$A*design$B*design$C*design$D*design$E
# Add a column for the response variable
design$response <- rnorm(32)
# Fit a linear model to the data
fit <- lm(response ~ A*B*C*D*E + interaction, data = design)
# Print the summary of the model
summary(fit)
# Create an interaction plot for the highest interaction
interaction.plot(design$interaction, design$response)
# Create an interaction plot for the highest interaction
interaction.plot(design$interaction, response=design$response)
# Create an interaction plot for the highest interaction
interaction.plot(design$interaction, design$A response=design$response)
library(lattice)
library(lsmeans)
install.packages("lsmeans")
library(lsmeans)
# Generate data
set.seed(123)
factors <- c("A", "B", "C", "D")
n <- 8 # number of blocks
data <- data.frame(block = rep(1:n, each = 2^4))
for (factor in factors) {
data[,factor] <- rep(c(0,1), length.out = n*2^3)
}
library(lattice)
library(lsmeans)
# Generate data
set.seed(123)
factors <- c("A", "B", "C", "D")
n <- 8 # number of blocks
data <- data.frame(block = rep(1:n, each = 2^4))
for (factor in factors) {
data[,factor] <- rep(c(0,1), length.out = n*2^3)
}
data$response <- rnorm(n*2^4, mean = 2*data$A + 3*data$B + 2*data$C + 4*data$D +
2*data$A*data$B + 3*data$A*data$C + 4*data$A*data$D +
3*data$B*data$C + 4*data$B*data$D + 5*data$C*data$D +
6*data$A*data$B*data$C + 7*data$A*data$B*data$D +
8*data$A*data$C*data$D + 9*data$B*data$C*data$D +
10*data$A*data$B*data$C*data$D, sd = 2)
# Fit model
model <- lm(response ~ A*B*C*D + block, data = data)
View(data)
View(model)
# Get ANOVA table
library(car)
Anova(model, type = "III")
# Get least square means
lsmeans(model, "A:B:C:D")
install.packages("car")
# Get ANOVA table
library(car)
Anova(model, type = "III")
# Get least square means
lsmeans(model, "A:B:C:D")
library(lsmeans)
Anova(model, type = "III")
# Get least square means
lsmeans(model, "A:B:C:D")
library(lattice)
library(lsmeans)
# Get ANOVA table
library(car)
Anova(model, type = "III")
# Get least square means
lsmeans(model, "A:B:C:D")
library(lme4)
# Generate data
set.seed(123)
factorA <- rep(c(0,1), each=8)
factorB <- rep(c(0,1), times=4, each=4)
library(lme4)
# Generate data
set.seed(123)
factorA <- rep(c(0,1), each=8)
factorB <- rep(c(0,1), times=4, each=4)
factorC <- rep(c(0,1), times=2, each=8)
factorD <- rep(c(0,1), times=1, each=16)
block <- rep(1:4, times=4)
response <- rnorm(16, mean=5, sd=1) +
2*factorA + 3*factorB + 4*factorC + 5*factorD +
3*factorA*factorB + 2*factorC*factorD +
4*factorA*factorC + 6*factorA*factorD +
7*factorB*factorC + 8*factorB*factorD +
9*factorA*factorB*factorC + 10*factorA*factorB*factorD +
11*factorA*factorC*factorD + 12*factorB*factorC*factorD +
13*factorA*factorB*factorC*factorD +
rnorm(16, mean=0, sd=1)
# Fit model
model <- lmer(response ~ factorA*factorB*factorC*factorD + (1|block))
summary(model)
# Fit model
model <- lmer(response ~ factorA*factorB*factorC*factorD + (1|block), drop.unused.levels = TRUE)
factorA <- rep(c(0,1), each=8)
factorA
factorB
factorD
factorB <- rep(c(0,1), times=4, each=2)
factorA <- rep(c(0,1), times=8)
factorA
factorB
factorC <- rep(c(0,1), times=2, each=4)
factorC
factorD <- rep(c(0,1), times=1, each=8)
block <- rep(1:4, times=4)
block
int = (factorA+factorB+factorC+factorD)%2
int = (factorA+factorB+factorC+factorD) mod 2
3%2
int = (factorA+factorB+factorC+factorD) %% 2
int
factorD <- rep(c(-1,1), times=1, each=8)
# Generate data
set.seed(123)
factorA <- rep(c(-1,1), times=8)
factorB <- rep(c(-1,1), times=4, each=2)
factorC <- rep(c(-1,1), times=2, each=4)
factorD <- rep(c(-1,1), times=1, each=8)
int = (factorA+factorB+factorC+factorD) %% 2
factorA <- rep(c(-1,1), times=8)
factorB <- rep(c(-1,1), times=4, each=2)
factorC <- rep(c(-1,1), times=2, each=4)
factorD <- rep(c(-1,1), times=1, each=8)
int = (factorA*factorB*factorC*factorD)
?qnorm
pnorm(-1.2)
pnorm(.8)-pnorm(-1.2)
pnorm(.8)
pnorm(.08)-pnorm(-1.2)
weib = function(x,a,lambda){
1-exp(-(lambda*x)^a)
}
weib(6,2,4)
1-exp(-(4*6)^2)
exp(-(4*6)^2)
1-exp(-(4/6)^2)
pweibull(4,6,2)
pweibull(6,2,4)
exp(1)
1-exp(-((lambda*x)^a))
weib = function(x,a,lambda){
1-exp(-((lambda*x)^a))
}
weib(6,2,4)
pweibull(6,2,.25)
weib(6,2,.25)
weib(6,2,4)
pweibull(6,2,.25)
weib(6,2,.25)
library(bangladesh)
bangladesh::get_map("division")
plot(get_map("division"))
plot(get_map("district"))
plot(get_map("District"))
strataI = c(0, 1, 1, 2, 5, 4, 7, 7, 8, 6)
strataII = c(6, 8, 9, 10, 13, 12, 15, 16, 16, 17)
strataIII = c(18, 19, 20, 20, 24, 23, 25, 28, 29, 27)
strataIV = c(26, 30, 31, 31, 33, 32, 35, 37, 38, 38)
data = data.frame(strataI, strataII, strataIII, strataIV)
n = length(data)
k = 10
N =k*n
strataMeans = apply(data, 2, mean)
sampleMeans = apply(data, 1, mean)
popMean = mean(strataMeans)
data
sampleMeans
strataI = c(0, 1, 1, 2, 5, 4, 7, 7, 8, 6)
strataII = c(6, 8, 9, 10, 13, 12, 15, 16, 16, 17)
strataIII = c(18, 19, 20, 20, 24, 23, 25, 28, 29, 27)
strataIV = c(26, 30, 31, 31, 33, 32, 35, 37, 38, 38)
data = data.frame(strataI, strataII, strataIII, strataIV)
n = length(data)
k = 10
N =k*n
strataMeans = apply(data, 2, mean)
sampleMeans = apply(data, 1, mean)
popMean = mean(strataMeans)
data
n
vsy = sum((sampleMeans - popMean)**2)/k
vsy
x = c(32.71,7.97,0.62,15.61,42.85,46.85,9.39,6.33,
5.03,94.65,53.71,0.67,0.82,2.15,0.43,123.36,
0.29,3.00,4.00,2.00,6.21,45.89)
y = c(2328,758,105,949,3091,1736,840,311,0,3044,
2483,128,102,601,0,11749,26,317,190,180,752,
3091)
pop = data.frame(x=x, y=y)
pop
library(bangladesh)
bd_plot(level = "country", type = "static")
bd_plot(level = "district", type = "static")
bd_plot(level = "district", type = "interactive")
bd_search("amtali", level = "union", as.is = TRUE, coordinates = TRUE)
country <- get_map("country")
division <- get_map("division")
district <- get_map("district")
country
plot(country)
plot(district)
plot(division)
1-pmorm(22.5-3*7.5)
1-pnorm(22.5-3*7.5)
22.5-3*7.5
shiny::runApp('C:/Users/mdtak/OneDrive/Desktop/ASPL/AuctionDashboard')
